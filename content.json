{"pages":[],"posts":[{"title":"aspect-ratio：等比例縮放區塊的屬性來了！","text":"開發的時候常常遇到需要固定區塊比例的情境，而且通常長寬都不是絕對的數值。之前都是利用 padding 的特性去做等比例區塊。但現在有了更方便的 aspect-ratio，加上 vw/vh ，整理了 3 個可以使用的方法： 1. vw or vhvw、vh分別指瀏覽器的寬度以及高度，這個方法在佈局比較簡單的行動版裝置上比較可行。以下是一個長寬都是50%螢幕寬度的正方形： 1234.square-box { width: 50vw; height: 50vw;} 2. padding + positionpadding 有個特性——給予的值是百分比時，百分比的數值是基於父層元素的寬度、而不是元素本身。假設現在需要一個 16:9 的區塊，可以這樣做：透過width: 100% ：取得 .parent 寬度的 100%;padding-bottom: 56.25% ：取得 .parent 寬度的 56.25%;製作出 16:9 等比例縮放的外層 .outer 後，再絕對定位內層 .content ，並將寬高皆設置成 100%，就能得到一個與外層相同大小，但可以任意佈局內部元素的區塊了！ See the Pen aspect-radio by jyun1 (@jyun1desu) on CodePen. 懶得計算的話，也可以用 calc()： 1234.child { width: 100%; padding-bottom: calc(9/16 * 100%);} 3. 簡單暴力的 aspect-ratioaspect-ratio 是滿新的 CSS 屬性，支援度可以看這裡。只要使用 aspect-ratio: ratio;， ratio 的表現方式是width/height（有夠簡單！）。也能設置最大寬度、高度，依然會維持等比例，感覺這點是方法2做不到的。 See the Pen aspect-radio by jyun1 (@jyun1desu) on CodePen. 參考資料W3C Aspect Ratios","link":"/2021/08/01/aspect-ratio/"},{"title":"Recoil: React官方推出的狀態管理工具","text":"Recoil 是 Facebook 在2020推出的狀態管理 Library，還在實驗階段（不推薦用在大型專案）。雖然不像 redux 有各種神奇的用法，但比起來少了很多固定的語法要寫，使用起來很簡單！ 核心概念一圖以蔽之的概念圖： Recoil中有兩種 shared state ，都能夠被訂閱、更新： atom： 是 shared state 的基本單位。 selector： 為一 pure function ，透過輸入其他的 shared state ，輸出成需要的資料(derived data)。在輸入的 shared state 更新時才會重新計算。 在shared state更新時，只有訂閱該 shared state 的元件會重新渲染。 atom()每個atom都需要 unique key 和預設值： 12345678910const todoList = atom({ key: 'todoList', default: [{task: '看一本書',isComplete: false}, {task: '打掃家裡',isComplete: true}]});const todoListfilter = atom({ key: 'todoListfilter', default: 'default'}); 在component中，Recoil 提供了幾個 API ：跟useState()很像，但括號內放入的不是預設值，是atom。 useRecoilValue()：取值1const list = useRecoilValue(todoList); useSetRecoilState()：設值使用這個 hook 時，shared state改變時component不會重新渲染。1const setTodos = useSetRecoilState(todoList); useRecoilState()：取值及設值1const [list,setTodos] = useRecoilState(todoList) useResetRecoilState()：能將atom設定為預設值， selector()每個selector也都需要 unique key，以及get、set(非必要) method。 以 todoList 為例，有了 todoList 和目前的 filter 狀態，就可以利用selector計算當前頁面要顯示的資料了。 1234567891011121314151617181920212223242526272829const filteredTodos = selector({ key: 'filteredTodos', get: ({get}) =&gt; { const filter = get(todoListfilter); const list = get(todoList); switch (filter) { case 'done': return list.filter((item) =&gt; item.isComplete); case 'undone': return list.filter((item) =&gt; !item.isComplete); default: return list; } }, //optional set: ({get, set}, newValue) =&gt; { ... }})const TodoList = () =&gt; { const todoList = useRecoilValue(filteredTodos); return (&lt;ul&gt; {todoList.map(todo=&gt;(&lt;li&gt;{todo.task}&lt;/li&gt;))} &lt;/ul&gt;)} 取值和設值都可以透過get取得其他shared state的資料。 非同步資料串接atom及selector都可以利用非同步的方式串接資料： 12345678910111213const userID = atom({ key: 'userID', default: null,});const userData = selector({ key: 'userData', get: ({get}) =&gt; { const id = get(userID) const response = await fetchUserData({id}); return response.data; }}) 利用useRecoilValue()獲得非同步的shared state時，可以搭配 React 的&lt;Suspense&gt;使用來製作載入效果。如果不想，Recoil也有另外提供 API : useRecoilValueLoadable() useRecoilStateLoadable() 不同於useRecoilValue()回傳ERROR或是PROMISE，這兩個hooks在遇到非同步串接時會回傳含有state、content的物件： key/回傳內容 成功 失敗 loading state 'hasValue' 'hasError' 'loading' content 回傳的資料 error object Promise family系列 ← 覺得很酷可以帶入外部引數至atom、selector中的酷東東。 atomFamily()有時需要動態產生atom時，就可以使用atomfamily()。官方舉了一個例子來講解使用時機： 假設你做的是一個UI編輯頁面，使用者可以動態新增元件、而且每個元件都有自己的大小、顏色、位置⋯⋯等狀態。 這時不能確定需要幾個atom，又不想把個別元件的樣式全部塞進一個atom時，應該怎麼辦～？在官方推薦影片（9:55-12:00）推出時，可能還沒有atomfamily()這個語法，為了解決問題，大叔透過帶入不重複的引數動態新增atom： 123456789const itemWithId = memorize(id =&gt; atom({ key: `item${id}`, default: { color: pink, position: {0,0} }}))const CanvasElement = ({elementID}) =&gt; { const [itemData, setItemData] = useRecoilValue(itemWithId(elementID)); return (...);} 現在Recoil提供了更方便的atomFamily()： 123456789const itemFamily = atomFamily({ key: 'item', default: {...},});const CanvasElement = ({elementID}) =&gt; { const [itemData, setItemData] = useRecoilValue(itemFamily(elementID)); return (...);} 預設值 除了atom能放的之外，還能夠放帶有參數且有回傳值的function： 12345const itemFamily = atomFamily({ key: 'item', default: param =&gt; setColor(param),}); selectorFamily(options)類似selector()，但更強大的是能帶參數到get、set中。 1234567891011const selectColor = selectorFamily({ key: 'selectColor', get: param =&gt; ({get}) =&gt; { return ... ; }, set: param =&gt; ({set,get}, newValue) =&gt; { return ... ; },}); atomFamily()的預設值可以放function，也可以使用selectFamily()： 1234567const item = atomFamily({ key: ‘item’, default: selectorFamily({ key: 'colorSelect', get: param =&gt; ({get}) =&gt; selectColor(param); }),}); 同一個selectFamily()接收到相同的引數時，會回傳相同的selector實體。 最後一個別忘了&lt;RecoilRoot&gt;！可以有複數個&lt;RecoilRoot&gt;共存，不會互相影響。但若有巢狀的&lt;RecoilRoot&gt;，最內層會覆蓋外層。 123456789import { RecoilRoot } from 'recoil';function App() { return ( &lt;RecoilRoot&gt; &lt;ComponentThatUsesRecoil /&gt; &lt;/RecoilRoot&gt; );} 參考資料 Recoil Doc Recoil GitHub 官方推薦的影片 Redux vs Recoil Recoil - a New State Management Library for React CodeSandbox Sample","link":"/2021/07/28/recoil/"},{"title":"transform vs position：瀏覽器渲染的簡單介紹","text":"有天睡覺前突然想到（就是這麼突然），用 transform 跟 left, top 都可以改變元素位置的話，那是差在哪🧐？就查了一下，原來跟瀏覽器的渲染有關係啊。 重要的數字：60fps作為前端工程師最重要的任務之一應該就是讓你的網頁互動多多、又滑又順，使用者、PM大家都開開心心。任何卡卡或是顫抖的感覺（Juddering）都會破壞開開心心。 為什麼會卡卡？現今大多瀏覽器的更新頻率都是每秒60幀，換算下來每個畫面（1幀）大約有 16ms 左右來渲染畫面，聽起來已經有夠少。但瀏覽器它還有其他事要處理，所以大約只能撥 10ms 來處理畫面。 當事情太多，沒辦法在時間內處理完時，瀏覽器的畫面率（每秒幀數）就會下降，使用者就會感覺到卡卡的。 而提升效能——讓瀏覽器減少要做的事、只做必要的事，就變得很重要了！ 像素管道(The pixel pipeline)瀏覽器渲染的過程有五個主要步驟，也是前端工程師最能控制的部分：圖片來源：Rendering Performance JavaScript：主要用來處理形成視覺變更的工作， Style：套用 CSS 規則在對應的元素上，並計算元素的最終樣式 Layout：計算元素間的版面配置。一個元素往往可以影響許多其他元素。 Paint：繪製元素的視覺化效果，如文字、圖片、顏色、陰影、邊框⋯⋯等。描繪通常是在多重的層(layers)上進行。 Composite：合成步驟。完成描繪後，需要將 layers 以正確的順序描繪至螢幕（尤其是有重疊的狀況發生時）。 當 Layout、Paint、Compositing 任一步驟被觸發時，它後面的步驟也會跟著被觸發。無需處理到的步驟則會被跳過。有以下這三種情境： change Layout property ：更新與版面配置有關的屬性，如： width、height left、right、top、bottom margin 由於這些屬性會影響元素與其他元素間的關係，瀏覽器不只需要處理該元素、也必須檢查所有其他元素。之後才重新將整個網頁排版(reflow)，並進行後續的渲染行為。 change Paint property更新與元素視覺相關、而無改面版面配置的屬性，像是： background-image color 系列 text 系列 box-shadows border change Composite property若更改的屬性非 Layout 、 Paint 屬性，就只會觸發 Composite。目前來說是指這兩個屬性： transform opacity 💡 好用的查詢工具 💡CSS Triggers 可以查詢各 css 屬性會觸發的階段 看到這裡有燈泡冒出來嗎 💡💡💡💡💡？使用 left: 10px 與 transform: translateX(10px) 時看起來的效果可能一樣（也可能 transform 更 smoothy 一點），但瀏覽器渲染所需的成本差異卻很大。哇喔真的好神奇！ 另外 Style 也是有可以優化的地方，像是選擇器的複雜度就會影響瀏覽器查找的時間。希望之後也可以來寫一篇！推薦可以閱讀： Optimizing CSS: ID Selectors and Other Myths 參考資料(兼推薦閱讀)這兩篇是同個 Google 大師寫的，簡短有力： Simplify Paint Complexity and Reduce Paint Areas Rendering Performance 其他 Stick to Compositor-Only Properties and Manage Layer CountSmooth as Butter: Achieving 60 FPS Animations with CSS3CSS GPU Animation: Doing It Right","link":"/2021/08/14/render-performance/"},{"title":"styled-components 背後的魔法: Tagged template","text":"寫了一陣子的 styled-components，最近才知道原來styled.tag後面的``，就是 ES6 常常在寫的那個（打爆自己的笨頭），它的名字是 backtick。除此之外還發現了神奇的用法，研究了一下覺得很有趣，尤其這篇文章寫得很詳細（官方推薦）！以下是看完之後做的紀錄，如果習慣看英文的話很推薦看看原文～ 先從最簡單的開始8！ 範本字面值 Template Literal / Interpolated String Literal以前要用很多 + 串起來的東東，現在只要用 backticks 加上 ${ 變數名稱 }，整個很清爽～backticks 之間的斷行、空格等也都會被保留！ 123456789const myFavorite = 'Lotso';const flavour = 'strawberries'// before ES6const introduceMyBearInES5 = 'My favorite bear is '+ myFavorite + ', and his tommy smells like'+ flavour +'.';// ES6const introduceMyBearInES6 = `My favorite bear is ${myFavorite}, and his tommy smells like ${flavour}.`; ${ 變數名稱 } 中除了字串，也能放入各種運算式，甚至是呼叫函式： 12345678910111213141516const getFullName = ({firstName, lastName}) =&gt; { return `${firstName} + ${lastName}`}const President = { firstName: 'Lotso', LastName: 'Bear' height: 50,}const introducePresident = `Our President is ${getFullName(President)}. He is ${President.height &gt; 80 ? 'tall' : 'short'}. `// 'Our President is Lotso Bear. // He is short.' 標籤模版 tagged template標籤模板指的是在函式後方直接用上 backticks ，很有趣的是印出來的argument會是陣列！ 12345678910const printSomething = (...args) =&gt; { console.log(...args)}//一般的函式printSomething('a', 'b') // 'a b'//標籤模版printSomething`` // ['']printSomething`I love Lotso` // ['I love Lotso'] 雖然有點差異，但是其實跟一般的函式相差不遠。但如果模板字符串中有使用到 placeholder (就是那個熟悉的${...})，就會發生很神奇的事情！ 123456789101112const myFavorite = 'Lotso';const printSomething = (...args) =&gt; { console.log(...args)}/* 呼叫 printSomething, 並將模版字符串作為引數代入 */printSomething(`My favorite bear is ${myFavorite}.`) // 'My favorite bear is Lotso.'/* call printSomething as a tagged template literal(標籤樣板字面值)*/printSomething`My favorite bear is ${myFavorite}.`//[&quot;My favorite bear is &quot;, &quot;.&quot;], &quot;Lotso&quot; 當非使用一般代入的形式、而是在 printSomething 後方使用標籤樣板字面值時，會得到一 Array 作為第一個變數，第二個則是placeholder myFavorite 的值。而第一個 Array 內的值看起來是由 myFavorite 所在的位置去區隔的 再來多塞一個插入值看看： 123456789const myFavorite = 'Lotso';const flavour = 'strawberries'printSomething`My favorite bear is ${myFavorite}, and his tommy smells like ${flavour}.`;/*** [&quot;My favorite bear is &quot;, &quot;, and his tommy smells like &quot;, &quot;.&quot;] * &quot;Lotso&quot; * &quot;strawberries&quot;**/ 在回傳值中，第一個變數會是一陣列，內有非插入值的所有字串；而插入值則會依序排列在後方的變數中。再來看一次比較： 123456789101112const myFavorite = 'Lotso';const flavour = 'strawberries'printSomething(`My favorite bear is ${myFavorite}, and his tommy smells like ${flavour}.`) // &quot;My favorite bear is Lotso, and his tommy smells like strawberries.&quot;printSomething`My favorite bear is ${myFavorite}, and his tommy smells like ${flavour}.`;/*** [&quot;My favorite bear is &quot;, &quot;, and his tommy smells like &quot;, &quot;.&quot;] * &quot;Lotso&quot; * &quot;strawberries&quot;**/ 特點介紹完畢！那它神奇好用的地方在哪裡呢！！！請看以下： 在 styled-components 中的妙用簡單舉一個 styled-components 中的語法： 123456789const Button = styled.button` font-size: ${props =&gt; props.primary ? '2em' : '1em'};`// font-size: 2em;&lt;Button primary /&gt;// font-size: 1em;&lt;Button /&gt; 寫起來很順，從來沒想過這是怎麼做到的XDtagged template 起了什麼作用？ 先來看放函式在插入值中會印出什麼： 123456789101112const printSomething = (...args) =&gt; { console.log(args)}printSomething(`font-size: ${(primary) =&gt; primary ? '2em' : '1em'}`)// &quot;font-size: (primary) =&gt; primary ? '2em' : '1em'&quot; &lt;- 只是一坨字串printSomething`font-size: ${(primary) =&gt; primary ? '2em' : '1em'}`/*** [&quot;font-size: &quot;, &quot;&quot;,]* (primary) =&gt; primary ? '2em' : '1em' &lt;- 好像是字串又好像是函式**/ magic～～～這裡的 (primary) =&gt; primary ? '2em' : '1em' 是貨真價實的函式！ 既然是函式，那就只剩下執行它這個任務了！來改寫一下很簡陋的 printSomething，順便改名成 printStyles ： 1234567891011121314151617181920212223242526let protoStyledComponent = { printStyles(...args) { const [literalArr, ...placeholders] = args; const styles = placeholders.reduce((result, expr, index) =&gt; { /* 最大重點：如果是函式就執行它！ */ const value = typeof expr === 'function' ? expr(this.props) : expr; return result + value + literalArr[index + 1]; }, literalArr[0]); return styles; }}let component = Object.create(protoStyledComponent);component.props = { primary: true, color: 'pink' }; // 塞一些假的propscomponent.printStyles`font-size: ${(props) =&gt; props.primary ? '2em' : '1em'};color: ${(props)=&gt; props.color}`/*&quot;font-size: 2em;color: pink;&quot;*/ 登登！！！好神奇R～～～突然多瞭解了一點點每天在寫的東西，寫起來好像也更頭腦清楚了！後續的更多底層處理，可以看這篇。 參考資料The magic behind 💅 styled-components","link":"/2021/07/19/tagged-template/"},{"title":"可測試的 JavaScript Ch0、Ch1","text":"有一次聽到「先寫測試再寫程式」覺得太酷了8～就很想成為很會寫測試的人（也就會順便變成很會寫程式！？）。前陣子買了這本書，看了一半覺得有點難XD所以回頭再讀一次、寫下筆記，更確定自己有讀進去🐣（前言跟第一章完全沒有程式的部分，讚！） 前言既有的程式碼？《Work Effectively with Legacy Code》的作者定義既有的程式碼(legacy code)為沒有測試的程式碼。當這些從別處來到我們手中，或者從我們手中去到其他開發人員手上時，需要新增功能、除錯、或是為它撰寫測試時，很多人會選擇整個重寫以防改A壞B。而避免寫出難以維護的既有的程式碼的最佳方法就是好好寫測試。 避免造成災難的原因：高複雜度、緊實耦合寫程式的時候如果能隨時注意到是否具有可測試性(testability)，就更容易能寫出相對應的測試程式。而這樣的程式也相對更容易保持低複雜度、鬆散耦合的狀態。 什麼是可測試(testable)的程式？就是第一章的內容了： 第一章：可測試的 JavaScript既有的軟體開發流程軟體開發流程是一套可以重複實行的作業流程，透過標準化與規則話這些流程來改善開發人員的程式碼品質——無臭蟲、無缺失。（但開發人員的個人意志也是很重要的XD) 敏捷開發 Agile Development因應瀑布式(waterfall model)而生。敏捷開發把任務切成較小的單位、縮短運作週期，讓每個相關人員都一直有事可以做、人員間的合作也會更密切。 瀑布式：依序執行每個獨立、不平行的開發流程，例如：先寫規格→寫程式→做測試→部署。 敏捷測試本身沒有規範怎麼寫程式、也不一定會提升開發速度/品質，但比起瀑布式開發，它擁有更大的彈性，在需求變更時能更快將其納入開發流程中。 測試驅動開發 Test-Driven Development(TDD)先寫測試再開始開發。TDD也是避免前言中提到的既有的程式碼的最好方法。 行為驅動開發 Behavior-Driven Development(BDD)建立在TDD之上，透過使用者情境（user stories）來定義程式的規格、期望的結果。 測試「即」驅動開發 Test-While-Driven Development(TWDD)作者提出的軟體開發做法，開發與測試幾乎同時完成：寫一部分開發、隨後補上測試；或者寫一些測試後馬上寫上程式。 小結無論是使用何種方式，研究指出測試的數量與程式的品質成正比——無論是在開發前、中、後，能夠多寫一點測試都是絕對無害的。 可測試的程式碼就是容易做測試的程式碼，而這樣的程式碼通常也容易被維護、容易被瞭解——好懂好 debug！ 可維護的程式碼：不要一大堆亂七八糟寫在一起！ 短小 獨立 可了解的程式碼 完整的註解 有意義的命名 前後一致的程式碼慣例 測試的種類單元測試（unit testing）以程式中最小的邏輯單位寫測試程式，來驗證邏輯是否正確，通常用在測試 pure function：輸入 input 是否有達到預期中的 output。 整合測試（integration testing）測試整合多個邏輯下的情況，確保模組與模組之間的互動行為是正常的。以前端來說的話可能是一個 React Component 中的各種行為（跟DOM互動、串接API等等）。 效能與負載測試（performance and loading testing）確認程式執行是否符合規格 端對端測試（End-to-End test）這是作者沒有提到的部分，E2E test可以撰寫程式來模擬使用者操作網頁的流程（就是把人工的部分轉變成程式執行）。","link":"/2021/07/30/testablejs0001/"},{"title":"可測試的 JavaScript Ch2 複雜度（上）","text":"雖然完全精確測量程式複雜度的方法是不存在的，但有幾個重要的指標能夠測量出部分的程式複雜度： 程式碼大小(code size) 循環複雜度(cyclomatic complexity) 扇入 扇出 ⋯⋯等等可以測量出部分的程式複雜度。使用這些項目去檢視自己的程式碼，是建立可測試的程式的良好開始。 程式碼大小（Code Size）雖然整個專案中必要的程式碼的數量不太可能改變，但每個函式的大小、或是每個檔案中的函式數量可以改變的（檔案內的函式應該盡量相關）！ 命令與查詢將命令(command)與查詢(query)分開是維持函式最小尺寸的方式之一： 命令：可以視為 setters ， 為 做某件事 的函式 查詢：可以視為 getters ， 為 傳回某個結果 的函式 使用這種把讀與寫分開的方式撰寫函式，除了能精簡程式、提高可讀性外，測試時的彈性也更高。 不好的示範： 1234567891011121314151617181920212223function configure(values) { const fs = require('fs'); const config = { docRoot: '/root' }; let key; let state; for(key in values) { config[key] = values[key] } try { state = fs.statSync(config.docRoot); if(!state.isDirectory()){ throw new Error('is not valid'); } } catch(e) { console.log(`** ${config.docRoot} does not exist`) return; } //..validate other values... return config;} 這段程式中除了將 values 中的值寫入 config ，還要驗證資料，除了測試寫起來會很龐大、沒有焦點外，也不能單獨驗證config的內容。 如果將這段程式碼拆寫： 1234567891011121314151617181920212223242526function configure(values) { const config = { docRoot: '/root' }; let key; for(key in values) { config[key] = values[key] } validateDocRoot(config); validateSomething(config); return config;}function validateDocRoot(config) { const fs = require('fs'); cosnt state = fs.statSync(config.docRoot); if(!state.isDirectory(）){ throw new Error('is not valid'); }}//validate other values...function validateSomething(config) { ...} 瞬間變得清楚多了！也能針對單一項目去做驗證、測試。作者後續還有做一些改良，但這個步驟就很能說明將命令與查詢分開的好處了。 JSLint這本書是 2014 年出版的，現在比較常用的類似工具是 ESLint。用來分析程式碼中是否有**不良的風格 (style)、語法 (syntax) 以及語意 (semantics)**，以提高程式碼的可讀性。 循環複雜度 Cyclomatic Complexity指的是在程式中無相依關聯的程式碼數量。即為了測試所有程式碼，所需撰寫的單元測試之最小數量（測試覆蓋率100%時，所需要最小的單元測試數量）。 💡 測量工具： JSmeter jecheckstyle + Jenkins VScode 中可以安裝 CodeMetrics 以下是一個循環複雜度 2 的函式： 1234567const sum = (a, b) =&gt; { if(typeof a !== typeof b){ throw new Error(&quot;can't sum different types!&quot;); } else { return a + b } } 查找表循環複雜度較高時，通常表示程式碼內有許多 if/else 或是 switch 陳述句，將之改寫為查找表： 123456789101112131415161718192021// if/else陳述句const doSomething = a =&gt; { if(a === 'x') { doX(); } else if (a === 'y') { doY() } else { doZ(); }}// 查找表const doSomething = a =&gt; { const lookup = { x: doX, y: doY }; const default = doZ; lookup[a] ? lookup[a]() : default();} 改寫後雖然沒有減少需撰寫的單元測試數量，但撰寫的做法有所改變： if/else：對單一函式撰寫多個單元測試12345678910111213describe('Test doSomething', () =&gt; { test('a is x', () =&gt; { ... }) test('a is y', () =&gt; { ... }) test('default', () =&gt; { ... })}); 查找表：對多個較小的函式寫對應的單元測試1234567891011121314151617describe('Test lookup x', () =&gt; { test('doX', () =&gt; { ... })});describe('Test lookup y', () =&gt; { test('doY', () =&gt; { ... })});describe('Test default', () =&gt; { test('doZ', () =&gt; { ... })}); 可維護性提高，感覺也更好讀了！ 重複使用 Reuse減少程式碼的大小最好的方式就是降低撰寫數量。一個典型的應用程式大約有 85% 以上是使用他人撰寫好的程式碼（套件、框架等等），只有 15% 會是開發者自行撰寫的。 除了善用第三方資源，更重要的是在這 15% 中重複自己的程式碼。對於重複出現的程式碼不要有「就多出這一次而已」的心態。","link":"/2021/08/04/testablejs0201/"},{"title":"可測試的 JavaScript Ch2 複雜度（下）","text":"扇出與扇入扇出 Fan-out扇出的定義是一個函式的內部流數目加上該函式更動到的全域資料數目以下狀況都可以被算作是函式A的內部流： A 呼叫 B B 呼叫 A ，且 A 回傳一個值、B 會利用這個值 C 呼叫 A 和 B ，並把 A 的輸出值傳給 B 扇入 Fan-in扇入的定義是內部流進入該函式的數目，加上從該函式取用內容的資料結構數目。大多情況下大的扇入數是好的，表示有越多共用程式的重複使用。 小結高的扇入數與扇出數可能暗示這個函示做了太多事，需要被重構。 耦合 Coupling扇出是計算一個模組或函式需求的相依模組與物件的數量，耦合則是表達這些模組、物件之間的關聯情況。耦合的程度由高到低分成六個等級： 內容耦合(5分)：直接修改物件本身的狀態1person.name = 'Lotso'; 共用耦合(4分)：兩個物件共用一個全域變數，彼此就是共用耦合關係。123456789let global = 'global';const a = () =&gt; { global = 'a';};const b = () =&gt; { global = 'b';} 控制耦合(3分)：利用旗標(flag)或參數設定控制外部物件的運作：1const whiteRabbit = new AbstractRabbit({color: 'white'}); 戳記耦合(2分)：經由參數傳遞一筆資料給物件A，A只會用到該資料的部分內容這裡的 makeBread 只用到 bread 的三個屬性，沒有用到 name：123456789101112Oven.prototype.makeBread = function({type, size, flavor}) { return new Bread(type, size, flavor)};const bread = { name: 'bread1', type: 'wheat', size: 99, flavor: 'macha'};Oven.makeBread(bread); 資料耦合(1分)：經由參數傳遞一筆資料給物件A，且沒有將資料的控制權轉給外部物件。在第三章會有更細的探討。 無耦合：兩個物件無關～～讚！ 將耦合程度越小（資料耦合、無耦合），測試起來越容易！ 實體 Instantiation實體化非獨生(nonsingleton)的全域物件雖不屬於上述的正規耦合類型，但是一種介於內容耦合與共用耦合之間、非常緊密的耦合類型。 在不使用此物件時，必須摧毀它。 物件實體越少，程式碼複雜度越低。如果發現程式碼用了太多物件、就是時候重新思考程式架構了！ 獨生/非獨生的概念可以參考這個，滿好懂的！ 相依性注入 Dependency Injection先來看一個緊密耦合的例子： 1234567function setParty() { const djPlayer = new DJPlayer(); const dishes = new Dishes(); this.placeDJPlayer(djPlayer); this.placeDishes(dishes);} 當準備要測試這個程式的時候，需要準備 DJPlayer 物件跟 Dishes 物件（這會使測試變得困難）。單元測試會希望不要依靠外部相依性就能獨立測試 setParty。 這時可以使用注入(injection)去減少耦合程度： 1234function setParty(djPlayer, dishes) { this.placeDJPlayer(djPlayer); this.placeDishes(dishes);} 這時候會有個疑問，如果這裡注入了一個物件，那還是有一個地方需要去建立它啊！！！沒錯，作者指出這件事通常會是在程式或測試的開頭。這樣的做法使得任意物件更容易與另一個物件做交替。 而且在寫測試時，也可以使用虛構的版本來替換注入的物件，使測試更加容易撰寫。 本章重點回顧 盡可能測量程式碼的複雜度，進而整理程式碼、提高可測試性、可維護性。 程式間的相依性（耦合）使得測試變得困難，可以使用注入的方式解決。 降低程式碼的複雜度無非就是了解何處複雜並且重構。作者推薦兩本書 Refactoring: Improving the Design of Existing Code Code Complete: A Practical Handbook of Software Construction 完全排除複雜度是不可能的，但可以透過正確的註解、良好的測試使之最小化。","link":"/2021/08/06/testablejs0202/"},{"title":"手動建立 Google 、 Facebook 第三方登入","text":"前陣子遇到客戶反應 Facebook、Google 第三方登入 API 在 instagram 、 Line 等內建瀏覽器(in-app browser) 無痕瀏覽模式 無法使用的問題，花了一段時間糾結跟解決QQ。意外學了很多以前不知道的東西，記錄一下！ 原先的做法利用 Facebook、Google 提供的 API ，使用起來很單純：開啟新分頁，使用者完成登入流程後回傳資料給原先的頁面並自動關閉。 🤯 in-app browser 的問題： 開啟新分頁這類瀏覽器大多 沒有分頁功能，會直接在同一頁做切換。原先等待回傳的那頁就消失了，也就無法收到回傳。 🤯 無痕瀏覽的問題： cookie 被阻擋Safari 和 Chrome 的表現不太一樣。Safari （14.0.3）沒問題，但 Chrome 會擋 cookie 進而影響到自家的登入API (傻眼) chrome 無痕模式下，使用 gapi.auth2.init 方法會出現的error message。 手動建立登入流程：one-page-flow主要是在同一頁面利用轉址的方式進行登入，並在最後將登入資料帶在轉回網址的參數中。從 原先：按下登入 → 開啟新分頁 → 登入 → 關閉分頁 → 原先登入頁接收 API 回傳 改成：按下登入 → 前往登入頁 → 登入 → 導回指定頁面，資料帶在網址中 只要設定好 登入頁的網址 就差不多成功了；導回後，也只要在 route 中去增加一些對參數的判斷、處理就好了。 Facebook覺得臉書寫的文件比較好懂，先拿臉書來當範例 123456https://www.facebook.com/v10.0/dialog/oauth? client_id={app-id} //required &amp;redirect_uri={登入完後的回傳址} //required &amp;state={防止跨網站偽造的的字串，也會被放在回傳網址中} //required &amp;response_type={回傳資料類型} //optional，預設為 code &amp;scope={你要向使用者要求的帳號權限} //optional Google除了可以看 JS Web Apps ，也可以一起看 Mobile and Desktop Apps 裡的內容，寫起來跟 facebook 幾乎完全一樣 XD： 123456https://accounts.google.com/o/oauth2/v2/auth? client_id={app-id} &amp;redirect_uri=https://jyun1desu.com/login &amp;state=google &amp;response_type=code &amp;scope=email%20profile 比較需要注意的參數： response_type code： 跟 API 直接取得 access_token 不同，需要走 server-side login：前端給後端 code ，由後端去換取 access_token。 token： 直接取得 access_token。 雖然直接設定 token 很方便，但資料不會以參數(?)、而是以網址片段(#)的方式存在。覺得這樣取資料有點麻煩、也有工程師建議 server-side login 後端的權限管理會比較踏實，就決定取 code 了（後端人很好）。 redirect_uri 要記得到當初在 facebook developer / google cloud 建立的應用程式中， 有效的 OAuth 重新導向 URI 新增有效網址。不在列表中的網址都會被擋下來(路徑、參數也都要填上)。 可是我想開啟新頁面 R撇除在 in-app browser 沒有分頁功能先不理它XD，這個方法最大的缺點是頁面都會在同一頁跳轉，跟多數使用者習慣的體驗是不一樣的。一開始想法是： in-app browser → 手動流程(不開新分頁) 一般瀏覽器 正常模式 → 保留使用API 無痕模式 → 手動流程(不開新分頁) 結果找不到判斷無痕的可靠方法…🥲 ，只能改成這樣： in-app browser → 手動流程(不開新分頁) 一般瀏覽器 → 手動流程(不開新分頁⋯⋯但好想開R！！！) 於是開始想要怎麼模擬 API 開啟新分頁、傳資料給隔壁分頁、自動關閉 的行為： 開啟新分頁：用 window.open() 即可 XD 自動關閉：這個也很簡單，用 window.close() 即可 XD 傳資料給隔壁分頁：這個好難RRRRRRR！！！！！ 糾結好幾天後（連 localStorage 搭配 visibilitychangeEvent 都試了🥲），發現很讚的 window.postMessage()MDN的解釋很詳細 ，以前居然不知道這個 API，本次最大收穫～～～ postMessage 可以實現同個瀏覽器下的溝通：tab間、彈出視窗與主視窗間、甚至和嵌入的 iframe 也可以～太方便啦！使用起來也滿直觀的： postMessage(message, targetOrigin, transfer) message：要傳送的資料，必填。 targetOrigin：限制接收對象的 origin ，使用字串 * 則代表無限制，必填。 transfer：看無….但好像不太用到。 監聽來自他方的 message 也很簡單：window.addEventListener('message', callback) 簡易的範例在按下第三方登入鈕的時候判斷是否是 in-app browser true： 不開啟新頁面 false： 開啟新頁面、 redirect_uri 多設定一個參數，判斷回來要做一些事 點擊第三方登入鈕觸發 openThirdPartyAuthPage： 1234567891011121314151617181920212223242526272829303132const addReciveMessageListener = () =&gt; { const reciveEvent = e =&gt; { const data = e.data if(origin === window.location.origin &amp;&amp; data.code) { doSomethingToLogin(data.code) window.removeEventListener('message', reciveEvent, false); } }; window.addEventListener('message', reciveEvent, false);};const getOAuthPageURL = (platform, isWebview) =&gt; { const redirect = isWebview? '.../login' : '.../login?type=auto-close'; switch(platform) { case 'facebook': return `https:// .....&amp;redirect_uri=${redirectUri}....`; case 'google': return `https:// .....&amp;redirect_uri=${redirectUri}....`; }}const toThirdPartyOAuthPage = platform =&gt; { const isWebview = ...; //做一些 in-app browser 的判斷 const authPageURL = getOAuthPageURL(platform, isWebview); if(isWebview){ window.location.href = authPageURL; } else { addReciveMessageListener(); window.open(authPageURL); }} 視窗回到 redirect_uri 後，在 route 中處理登入行為： 123456789101112131415161718// routes/Login/index.jsconst { code, type, ... } = 網址的query;const sendDataToLoginPage = () =&gt; { const loginData = { code }; window.opener.postMessage(loginData, 'http://jyun1desu.com');}if(code) { if(type === 'auto-close') { // normal browser redirect page sendDataToLoginPage(); window.close(); } else{ // in-app browser redirect page doSomethingToLogin(code) }} 成功的時候好感動啊～～～ 🎉🎉🎉 找資料的過程中也有看到 Broadcast Channel API ，雖然支援度還很悲劇，感覺是能先看起來的東西。最後謝謝 hahow ， 一度覺得解決不了的無很多問題，去看了 hahow 的網站之後才發現：嗯！果然是自己太淺ㄌ&gt;&lt;，就是有人做得到啊！！！而且寫這篇文章的時候，突然覺得是不是其實滿簡單的⋯⋯（但第一次碰到就是覺得很難QQ）。 以上！希望能幫助到正在困擾同樣問題的人 🎉 參考資料Google OAuthFacebook OAuthpostMessage API","link":"/2021/07/19/third-party-login/"}],"tags":[{"name":"css","slug":"css","link":"/tags/css/"},{"name":"Recoil","slug":"Recoil","link":"/tags/Recoil/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"rendering performance","slug":"rendering-performance","link":"/tags/rendering-performance/"},{"name":"效能調校","slug":"效能調校","link":"/tags/%E6%95%88%E8%83%BD%E8%AA%BF%E6%A0%A1/"},{"name":"styled-components","slug":"styled-components","link":"/tags/styled-components/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Tagged template","slug":"Tagged-template","link":"/tags/Tagged-template/"},{"name":"可測試的 JavaScript","slug":"可測試的-JavaScript","link":"/tags/%E5%8F%AF%E6%B8%AC%E8%A9%A6%E7%9A%84-JavaScript/"},{"name":"讀書筆記","slug":"讀書筆記","link":"/tags/%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/"},{"name":"複雜度","slug":"複雜度","link":"/tags/%E8%A4%87%E9%9B%9C%E5%BA%A6/"},{"name":"相依性注入","slug":"相依性注入","link":"/tags/%E7%9B%B8%E4%BE%9D%E6%80%A7%E6%B3%A8%E5%85%A5/"},{"name":"耦合","slug":"耦合","link":"/tags/%E8%80%A6%E5%90%88/"},{"name":"第三方登入","slug":"第三方登入","link":"/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%85%A5/"},{"name":"google登入","slug":"google登入","link":"/tags/google%E7%99%BB%E5%85%A5/"},{"name":"facebook登入","slug":"facebook登入","link":"/tags/facebook%E7%99%BB%E5%85%A5/"}],"categories":[{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"《可測試的 JavaScript》 讀書筆記","slug":"《可測試的-JavaScript》-讀書筆記","link":"/categories/%E3%80%8A%E5%8F%AF%E6%B8%AC%E8%A9%A6%E7%9A%84-JavaScript%E3%80%8B-%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/"}]}