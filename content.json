{"pages":[],"posts":[{"title":"Recoil: React官方推出的狀態管理工具","text":"Recoil 是 Facebook 在2020推出的狀態管理 Library，還在實驗階段（不推薦用在大型專案）。雖然不像 redux 有各種神奇的用法，但比起來少了很多固定的語法要寫，使用起來很簡單！ 核心概念一圖以蔽之的概念圖： Recoil中有兩種 shared state ，都能夠被訂閱、更新： atom： 是 shared state 的基本單位。 selector： 為一 pure function ，透過輸入其他的 shared state ，輸出成需要的資料(derived data)。在輸入的 shared state 更新時才會重新計算。 在shared state更新時，只有訂閱該 shared state 的元件會重新渲染。 atom()每個atom都需要 unique key 和預設值： 12345678910const todoList = atom({ key: 'todoList', default: [{task: '看一本書',isComplete: false}, {task: '打掃家裡',isComplete: true}]});const todoListfilter = atom({ key: 'todoListfilter', default: 'default'}); 在component中，Recoil 提供了幾個 API ：跟useState()很像，但括號內放入的不是預設值，是atom。 useRecoilValue()：取值1const list = useRecoilValue(todoList); useSetRecoilState()：設值使用這個 hook 時，shared state改變時component不會重新渲染。1const setTodos = useSetRecoilState(todoList); useRecoilState()：取值及設值1const [list,setTodos] = useRecoilState(todoList) useResetRecoilState()：能將atom設定為預設值， selector()每個selector也都需要 unique key，以及get、set(非必要) method。 以 todoList 為例，有了 todoList 和目前的 filter 狀態，就可以利用selector計算當前頁面要顯示的資料了。 1234567891011121314151617181920212223242526272829const filteredTodos = selector({ key: 'filteredTodos', get: ({get}) =&gt; { const filter = get(todoListfilter); const list = get(todoList); switch (filter) { case 'done': return list.filter((item) =&gt; item.isComplete); case 'undone': return list.filter((item) =&gt; !item.isComplete); default: return list; } }, //optional set: ({get, set}, newValue) =&gt; { ... }})const TodoList = () =&gt; { const todoList = useRecoilValue(filteredTodos); return (&lt;ul&gt; {todoList.map(todo=&gt;(&lt;li&gt;{todo.task}&lt;/li&gt;))} &lt;/ul&gt;)} 取值和設值都可以透過get取得其他shared state的資料。 非同步資料串接atom及selector都可以利用非同步的方式串接資料： 12345678910111213const userID = atom({ key: 'userID', default: null,});const userData = selector({ key: 'userData', get: ({get}) =&gt; { const id = get(userID) const response = await fetchUserData({id}); return response.data; }}) 利用useRecoilValue()獲得非同步的shared state時，可以搭配 React 的&lt;Suspense&gt;使用來製作載入效果。如果不想，Recoil也有另外提供 API : useRecoilValueLoadable() useRecoilStateLoadable() 不同於useRecoilValue()回傳ERROR或是PROMISE，這兩個hooks在遇到非同步串接時會回傳含有state、content的物件： key/回傳內容 成功 失敗 loading state 'hasValue' 'hasError' 'loading' content 回傳的資料 error object Promise family系列 ← 覺得很酷可以帶入外部引數至atom、selector中的酷東東。 atomFamily()有時需要動態產生atom時，就可以使用atomfamily()。官方舉了一個例子來講解使用時機： 假設你做的是一個UI編輯頁面，使用者可以動態新增元件、而且每個元件都有自己的大小、顏色、位置⋯⋯等狀態。 這時不能確定需要幾個atom，又不想把個別元件的樣式全部塞進一個atom時，應該怎麼辦～？在官方推薦影片（9:55-12:00）推出時，可能還沒有atomfamily()這個語法，為了解決問題，大叔透過帶入不重複的引數動態新增atom： 123456789const itemWithId = memorize(id =&gt; atom({ key: `item${id}`, default: { color: pink, position: {0,0} }}))const CanvasElement = ({elementID}) =&gt; { const [itemData, setItemData] = useRecoilValue(itemWithId(elementID)); return (...);} 現在Recoil提供了更方便的atomFamily()： 123456789const itemFamily = atomFamily({ key: 'item', default: {...},});const CanvasElement = ({elementID}) =&gt; { const [itemData, setItemData] = useRecoilValue(itemFamily(elementID)); return (...);} 預設值 除了atom能放的之外，還能夠放帶有參數且有回傳值的function： 12345const itemFamily = atomFamily({ key: 'item', default: param =&gt; setColor(param),}); selectorFamily(options)類似selector()，但更強大的是能帶參數到get、set中。 1234567891011const selectColor = selectorFamily({ key: 'selectColor', get: param =&gt; ({get}) =&gt; { return ... ; }, set: param =&gt; ({set,get}, newValue) =&gt; { return ... ; },}); atomFamily()的預設值可以放function，也可以使用selectFamily()： 1234567const item = atomFamily({ key: ‘item’, default: selectorFamily({ key: 'colorSelect', get: param =&gt; ({get}) =&gt; selectColor(param); }),}); 同一個selectFamily()接收到相同的引數時，會回傳相同的selector實體。 最後一個別忘了&lt;RecoilRoot&gt;！可以有複數個&lt;RecoilRoot&gt;共存，不會互相影響。但若有巢狀的&lt;RecoilRoot&gt;，最內層會覆蓋外層。 123456789import { RecoilRoot } from 'recoil';function App() { return ( &lt;RecoilRoot&gt; &lt;ComponentThatUsesRecoil /&gt; &lt;/RecoilRoot&gt; );} 參考資料 Recoil Doc Recoil GitHub 官方推薦的影片 Redux vs Recoil Recoil - a New State Management Library for React CodeSandbox Sample","link":"/2021/07/28/recoil/"},{"title":"styled-components 背後的魔法: Tagged template","text":"寫了一陣子的 styled-components，最近才知道原來styled.tag後面的``，就是 ES6 常常在寫的那個（打爆自己的笨頭），它的名字是 backtick。除此之外還發現了神奇的用法，研究了一下覺得很有趣，尤其這篇文章寫得很詳細（官方推薦）！以下是看完之後做的紀錄，如果習慣看英文的話很推薦看看原文～ 先從最簡單的開始8！ 範本字面值 Template Literal / Interpolated String Literal以前要用很多 + 串起來的東東，現在只要用 backticks 加上 ${ 變數名稱 }，整個很清爽～backticks 之間的斷行、空格等也都會被保留！ 123456789const myFavorite = 'Lotso';const flavour = 'strawberries'// before ES6const introduceMyBearInES5 = 'My favorite bear is '+ myFavorite + ', and his tommy smells like'+ flavour +'.';// ES6const introduceMyBearInES6 = `My favorite bear is ${myFavorite}, and his tommy smells like ${flavour}.`; ${ 變數名稱 } 中除了字串，也能放入各種運算式，甚至是呼叫函式： 12345678910111213141516const getFullName = ({firstName, lastName}) =&gt; { return `${firstName} + ${lastName}`}const President = { firstName: 'Lotso', LastName: 'Bear' height: 50,}const introducePresident = `Our President is ${getFullName(President)}. He is ${President.height &gt; 80 ? 'tall' : 'short'}. `// 'Our President is Lotso Bear. // He is short.' 標籤模版 tagged template標籤模板指的是在函式後方直接用上 backticks ，很有趣的是印出來的argument會是陣列！ 12345678910const printSomething = (...args) =&gt; { console.log(...args)}//一般的函式printSomething('a', 'b') // 'a b'//標籤模版printSomething`` // ['']printSomething`I love Lotso` // ['I love Lotso'] 雖然有點差異，但是其實跟一般的函式相差不遠。但如果模板字符串中有使用到 placeholder (就是那個熟悉的${...})，就會發生很神奇的事情！ 123456789101112const myFavorite = 'Lotso';const printSomething = (...args) =&gt; { console.log(...args)}/* 呼叫 printSomething, 並將模版字符串作為引數代入 */printSomething(`My favorite bear is ${myFavorite}.`) // 'My favorite bear is Lotso.'/* call printSomething as a tagged template literal(標籤樣板字面值)*/printSomething`My favorite bear is ${myFavorite}.`//[&quot;My favorite bear is &quot;, &quot;.&quot;], &quot;Lotso&quot; 當非使用一般代入的形式、而是在 printSomething 後方使用標籤樣板字面值時，會得到一 Array 作為第一個變數，第二個則是placeholder myFavorite 的值。而第一個 Array 內的值看起來是由 myFavorite 所在的位置去區隔的 再來多塞一個插入值看看： 123456789const myFavorite = 'Lotso';const flavour = 'strawberries'printSomething`My favorite bear is ${myFavorite}, and his tommy smells like ${flavour}.`;/*** [&quot;My favorite bear is &quot;, &quot;, and his tommy smells like &quot;, &quot;.&quot;] * &quot;Lotso&quot; * &quot;strawberries&quot;**/ 在回傳值中，第一個變數會是一陣列，內有非插入值的所有字串；而插入值則會依序排列在後方的變數中。再來看一次比較： 123456789101112const myFavorite = 'Lotso';const flavour = 'strawberries'printSomething(`My favorite bear is ${myFavorite}, and his tommy smells like ${flavour}.`) // &quot;My favorite bear is Lotso, and his tommy smells like strawberries.&quot;printSomething`My favorite bear is ${myFavorite}, and his tommy smells like ${flavour}.`;/*** [&quot;My favorite bear is &quot;, &quot;, and his tommy smells like &quot;, &quot;.&quot;] * &quot;Lotso&quot; * &quot;strawberries&quot;**/ 特點介紹完畢！那它神奇好用的地方在哪裡呢！！！請看以下： 在 styled-components 中的妙用簡單舉一個 styled-components 中的語法： 123456789const Button = styled.button` font-size: ${props =&gt; props.primary ? '2em' : '1em'};`// font-size: 2em;&lt;Button primary /&gt;// font-size: 1em;&lt;Button /&gt; 寫起來很順，從來沒想過這是怎麼做到的XDtagged template 起了什麼作用？ 先來看放函式在插入值中會印出什麼： 123456789101112const printSomething = (...args) =&gt; { console.log(args)}printSomething(`font-size: ${(primary) =&gt; primary ? '2em' : '1em'}`)// &quot;font-size: (primary) =&gt; primary ? '2em' : '1em'&quot; &lt;- 只是一坨字串printSomething`font-size: ${(primary) =&gt; primary ? '2em' : '1em'}`/*** [&quot;font-size: &quot;, &quot;&quot;,]* (primary) =&gt; primary ? '2em' : '1em' &lt;- 好像是字串又好像是函式**/ magic～～～這裡的 (primary) =&gt; primary ? '2em' : '1em' 是貨真價實的函式！ 既然是函式，那就只剩下執行它這個任務了！來改寫一下很簡陋的 printSomething，順便改名成 printStyles ： 1234567891011121314151617181920212223242526let protoStyledComponent = { printStyles(...args) { const [literalArr, ...placeholders] = args; const styles = placeholders.reduce((result, expr, index) =&gt; { /* 最大重點：如果是函式就執行它！ */ const value = typeof expr === 'function' ? expr(this.props) : expr; return result + value + literalArr[index + 1]; }, literalArr[0]); return styles; }}let component = Object.create(protoStyledComponent);component.props = { primary: true, color: 'pink' }; // 塞一些假的propscomponent.printStyles`font-size: ${(props) =&gt; props.primary ? '2em' : '1em'};color: ${(props)=&gt; props.color}`/*&quot;font-size: 2em;color: pink;&quot;*/ 登登！！！好神奇R～～～突然多瞭解了一點點每天在寫的東西，寫起來好像也更頭腦清楚了！後續的更多底層處理，可以看這篇。 參考資料The magic behind 💅 styled-components","link":"/2021/07/19/tagged-template/"},{"title":"手動建立 Google 、 Facebook 第三方登入","text":"前陣子遇到客戶反應 Facebook、Google 第三方登入 API 在 instagram 、 Line 等內建瀏覽器(in-app browser) 無痕瀏覽模式 無法使用的問題，花了一段時間糾結跟解決QQ。意外學了很多以前不知道的東西，記錄一下！ 原先的做法利用 Facebook、Google 提供的 API ，使用起來很單純：開啟新分頁，使用者完成登入流程後回傳資料給原先的頁面並自動關閉。 🤯 in-app browser 的問題： 開啟新分頁這類瀏覽器大多 沒有分頁功能，會直接在同一頁做切換。原先等待回傳的那頁就消失了，也就無法收到回傳。 🤯 無痕瀏覽的問題： cookie 被阻擋Safari 和 Chrome 的表現不太一樣。Safari （14.0.3）沒問題，但 Chrome 會擋 cookie 進而影響到自家的登入API (傻眼) chrome 無痕模式下，使用 gapi.auth2.init 方法會出現的error message。 手動建立登入流程：one-page-flow主要是在同一頁面利用轉址的方式進行登入，並在最後將登入資料帶在轉回網址的參數中。從 原先：按下登入 → 開啟新分頁 → 登入 → 關閉分頁 → 原先登入頁接收 API 回傳 改成：按下登入 → 前往登入頁 → 登入 → 導回指定頁面，資料帶在網址中 只要設定好 登入頁的網址 就差不多成功了；導回後，也只要在 route 中去增加一些對參數的判斷、處理就好了。 Facebook覺得臉書寫的文件比較好懂，先拿臉書來當範例 123456https://www.facebook.com/v10.0/dialog/oauth? client_id={app-id} //required &amp;redirect_uri={登入完後的回傳址} //required &amp;state={防止跨網站偽造的的字串，也會被放在回傳網址中} //required &amp;response_type={回傳資料類型} //optional，預設為 code &amp;scope={你要向使用者要求的帳號權限} //optional Google除了可以看 JS Web Apps ，也可以一起看 Mobile and Desktop Apps 裡的內容，寫起來跟 facebook 幾乎完全一樣 XD： 123456https://accounts.google.com/o/oauth2/v2/auth? client_id={app-id} &amp;redirect_uri=https://jyun1desu.com/login &amp;state=google &amp;response_type=code &amp;scope=email%20profile 比較需要注意的參數： response_type code： 跟 API 直接取得 access_token 不同，需要走 server-side login：前端給後端 code ，由後端去換取 access_token。 token： 直接取得 access_token。 雖然直接設定 token 很方便，但資料不會以參數(?)、而是以網址片段(#)的方式存在。覺得這樣取資料有點麻煩、也有工程師建議 server-side login 後端的權限管理會比較踏實，就決定取 code 了（後端人很好）。 redirect_uri 要記得到當初在 facebook developer / google cloud 建立的應用程式中， 有效的 OAuth 重新導向 URI 新增有效網址。不在列表中的網址都會被擋下來(路徑、參數也都要填上)。 可是我想開啟新頁面 R撇除在 in-app browser 沒有分頁功能先不理它XD，這個方法最大的缺點是頁面都會在同一頁跳轉，跟多數使用者習慣的體驗是不一樣的。一開始想法是： in-app browser → 手動流程(不開新分頁) 一般瀏覽器 正常模式 → 保留使用API 無痕模式 → 手動流程(不開新分頁) 結果找不到判斷無痕的可靠方法…🥲 ，只能改成這樣： in-app browser → 手動流程(不開新分頁) 一般瀏覽器 → 手動流程(不開新分頁⋯⋯但好想開R！！！) 於是開始想要怎麼模擬 API 開啟新分頁、傳資料給隔壁分頁、自動關閉 的行為： 開啟新分頁：用 window.open() 即可 XD 自動關閉：這個也很簡單，用 window.close() 即可 XD 傳資料給隔壁分頁：這個好難RRRRRRR！！！！！ 糾結好幾天後（連 localStorage 搭配 visibilitychangeEvent 都試了🥲），發現很讚的 window.postMessage()MDN的解釋很詳細 ，以前居然不知道這個 API，本次最大收穫～～～ postMessage 可以實現同個瀏覽器下的溝通：tab間、彈出視窗與主視窗間、甚至和嵌入的 iframe 也可以～太方便啦！使用起來也滿直觀的： postMessage(message, targetOrigin, transfer) message：要傳送的資料，必填。 targetOrigin：限制接收對象的 origin ，使用字串 * 則代表無限制，必填。 transfer：看無….但好像不太用到。 監聽來自他方的 message 也很簡單：window.addEventListener('message', callback) 簡易的範例在按下第三方登入鈕的時候判斷是否是 in-app browser true： 不開啟新頁面 false： 開啟新頁面、 redirect_uri 多設定一個參數，判斷回來要做一些事 點擊第三方登入鈕觸發 openThirdPartyAuthPage： 1234567891011121314151617181920212223242526272829303132const addReciveMessageListener = () =&gt; { const reciveEvent = e =&gt; { const data = e.data if(origin === window.location.origin &amp;&amp; data.code) { doSomethingToLogin(data.code) window.removeEventListener('message', reciveEvent, false); } }; window.addEventListener('message', reciveEvent, false);};const getOAuthPageURL = (platform, isWebview) =&gt; { const redirect = isWebview? '.../login' : '.../login?type=auto-close'; switch(platform) { case 'facebook': return `https:// .....&amp;redirect_uri=${redirectUri}....`; case 'google': return `https:// .....&amp;redirect_uri=${redirectUri}....`; }}const toThirdPartyOAuthPage = platform =&gt; { const isWebview = ...; //做一些 in-app browser 的判斷 const authPageURL = getOAuthPageURL(platform, isWebview); if(isWebview){ window.location.href = authPageURL; } else { addReciveMessageListener(); window.open(authPageURL); }} 視窗回到 redirect_uri 後，在 route 中處理登入行為： 123456789101112131415161718// routes/Login/index.jsconst { code, type, ... } = 網址的query;const sendDataToLoginPage = () =&gt; { const loginData = { code }; window.opener.postMessage(loginData, 'http://jyun1desu.com');}if(code) { if(type === 'auto-close') { // normal browser redirect page sendDataToLoginPage(); window.close(); } else{ // in-app browser redirect page doSomethingToLogin(code) }} 成功的時候好感動啊～～～ 🎉🎉🎉 找資料的過程中也有看到 Broadcast Channel API ，雖然支援度還很悲劇，感覺是能先看起來的東西。最後謝謝 hahow ， 一度覺得解決不了的無很多問題，去看了 hahow 的網站之後才發現：嗯！果然是自己太淺ㄌ&gt;&lt;，就是有人做得到啊！！！而且寫這篇文章的時候，突然覺得是不是其實滿簡單的⋯⋯（但第一次碰到就是覺得很難QQ）。 以上！希望能幫助到正在困擾同樣問題的人 🎉 參考資料Google OAuthFacebook OAuthpostMessage API","link":"/2021/07/19/third-party-login/"}],"tags":[{"name":"Recoil","slug":"Recoil","link":"/tags/Recoil/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"styled-components","slug":"styled-components","link":"/tags/styled-components/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Tagged template","slug":"Tagged-template","link":"/tags/Tagged-template/"},{"name":"第三方登入","slug":"第三方登入","link":"/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%85%A5/"},{"name":"google登入","slug":"google登入","link":"/tags/google%E7%99%BB%E5%85%A5/"},{"name":"facebook登入","slug":"facebook登入","link":"/tags/facebook%E7%99%BB%E5%85%A5/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}